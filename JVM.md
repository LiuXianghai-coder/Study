# 运行时数据区

![image.png](https://i.loli.net/2021/06/30/s6kIWBgu48a3oDX.png)

1. ### 方法区

   - Object Class Data（加载类定义数据）存储在方法区
   - 常量、静态变量、JIT 编译后的代码存储在方法区
   - 方法区与存储数据的堆区有一种类比关系，因此也被成为 No-Heap 区。方法区可以有内存不连续的区域组成，可以设置为固定大小，也可以设置为可扩展的，这点与堆区一致。
   - 垃圾回收在方法区出现频率较低，回收的主要目的是针对常量池的回收和类的卸载
   - 运行时常量池（Runtime Constant Poll）
     - 存储编译器产生的字面量和符号引用
     - 运行时产生的新常量也会放入常量池中，比如 `String` 的 `intern()` 方法
     - 常量池是这个类型用到的常量的有序集合。包括直接常量（基本数据类型、String）和对其它类型的、方法、字段的符号引用。主要包括：
       - 类和接口的全限定名
       - 字段和名称的描述符
       - 方法和名称的描述符
   - 永久代是 `HostSpot` 的一个具体实现，永久代是方法区的具体实现，方法区是 JVM 的一个概念。
   - `JDK 1.8` 之后使用元空间取代，不再放入 `JVM`，而是放入本地物理机器内存。元空间取代后将常量和静态变量等放入堆区，使得方法区不再进行垃圾回收。

2. ### 堆区

   - 内存数据区，在 `JVM`	 启动时被创建，专门用来保存对象的实例。
   - 保存对象的实例也只是保存对象的实例属性，属性类型和对象本身的类型标记等以栈帧的形式保存在虚拟机栈中。
   - 对象实例在堆区分配之后，将会将自身的引用保存在一个 Java 虚拟机栈中，用于定位该实例在堆区中的位置。
   - Java 堆区只需逻辑上的空间连续即可。

3. ### 虚拟机栈

   - 方法本身是指令的操作码部分，保存在 `Stack`  中。
   - 方法内部变量作为指令的操作数部分，跟在指令操作码之后，保存在 `Stack` 中，对象类型在 `Stack` 中保存地址，在堆区中保存实例。
   - 在线程创建时随之创建，它的生命周期跟随线程的生命周期，因此不存在垃圾收集。
   - 局部变量表存放了编译可知的各种基本数据类型、对象的引用和下一条字节码指令的地址。局部变量表所需的运行空间在编译期间完成分配，在方法运行前，该局部变量表所需要的内存空间是固定的，运行期间也不会发生改变。

4. ### 本地方法栈

   为 `native` 方法提供执行方法的服务

5. ### 程序计数器

   当前线程执行的字节码的位置指示器。

# 内存分配

1. `new` 一个对象的流程

   <img src="https://i.loli.net/2021/06/30/JnwOPt1KxcDmjfB.png" alt="image.png" style="zoom:150%;" />

2. 总体流程

   

3. 