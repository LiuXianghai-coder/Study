<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title></head>
<body>
<table>
    <tbody>
    <tr>
        <th>.proto Type</th>
        <th>Notes</th>
        <th>C++ Type</th>
        <th>Java Type</th>
        <th>Python Type<sup>[2]</sup></th>
        <th>Go Type</th>
    </tr>
    <tr>
        <td>double</td>
        <td></td>
        <td>double</td>
        <td>double</td>
        <td>float</td>
        <td>*float64</td>
    </tr>
    <tr>
        <td>float</td>
        <td></td>
        <td>float</td>
        <td>float</td>
        <td>float</td>
        <td>*float32</td>
    </tr>
    <tr>
        <td>int32</td>
        <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have
            negative values, use sint32 instead.
        </td>
        <td>int32</td>
        <td>int</td>
        <td>int</td>
        <td>*int32</td>
    </tr>
    <tr>
        <td>int64</td>
        <td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have
            negative values, use sint64 instead.
        </td>
        <td>int64</td>
        <td>long</td>
        <td>int/long<sup>[3]</sup></td>
        <td>*int64</td>
    </tr>
    <tr>
        <td>uint32</td>
        <td>Uses variable-length encoding.</td>
        <td>uint32</td>
        <td>int<sup>[1]</sup></td>
        <td>int/long<sup>[3]</sup></td>
        <td>*uint32</td>
    </tr>
    <tr>
        <td>uint64</td>
        <td>Uses variable-length encoding.</td>
        <td>uint64</td>
        <td>long<sup>[1]</sup></td>
        <td>int/long<sup>[3]</sup></td>
        <td>*uint64</td>
    </tr>
    <tr>
        <td>sint32</td>
        <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular
            int32s.
        </td>
        <td>int32</td>
        <td>int</td>
        <td>int</td>
        <td>*int32</td>
    </tr>
    <tr>
        <td>sint64</td>
        <td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular
            int64s.
        </td>
        <td>int64</td>
        <td>long</td>
        <td>int/long<sup>[3]</sup></td>
        <td>*int64</td>
    </tr>
    <tr>
        <td>fixed32</td>
        <td>Always four bytes. More efficient than uint32 if values are often greater than 2<sup>28</sup>.</td>
        <td>uint32</td>
        <td>int<sup>[1]</sup></td>
        <td>int/long<sup>[3]</sup></td>
        <td>*uint32</td>
    </tr>
    <tr>
        <td>fixed64</td>
        <td>Always eight bytes. More efficient than uint64 if values are often greater than 2<sup>56</sup>.</td>
        <td>uint64</td>
        <td>long<sup>[1]</sup></td>
        <td>int/long<sup>[3]</sup></td>
        <td>*uint64</td>
    </tr>
    <tr>
        <td>sfixed32</td>
        <td>Always four bytes.</td>
        <td>int32</td>
        <td>int</td>
        <td>int</td>
        <td>*int32</td>
    </tr>
    <tr>
        <td>sfixed64</td>
        <td>Always eight bytes.</td>
        <td>int64</td>
        <td>long</td>
        <td>int/long<sup>[3]</sup></td>
        <td>*int64</td>
    </tr>
    <tr>
        <td>bool</td>
        <td></td>
        <td>bool</td>
        <td>boolean</td>
        <td>bool</td>
        <td>*bool</td>
    </tr>
    <tr>
        <td>string</td>
        <td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
        <td>string</td>
        <td>String</td>
        <td>unicode (Python 2) or str (Python 3)</td>
        <td>*string</td>
    </tr>
    <tr>
        <td>bytes</td>
        <td>May contain any arbitrary sequence of bytes.</td>
        <td>string</td>
        <td>ByteString</td>
        <td>bytes</td>
        <td>[]byte</td>
    </tr>
    </tbody>
</table>
</body>
</html>